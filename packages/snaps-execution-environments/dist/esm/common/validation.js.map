{"version":3,"sources":["../../../src/common/validation.ts"],"sourcesContent":["import { ChainIdStruct, HandlerType } from '@metamask/snaps-utils';\nimport type { Json, JsonRpcSuccess } from '@metamask/utils';\nimport {\n  assertStruct,\n  JsonRpcIdStruct,\n  JsonRpcRequestStruct,\n  JsonRpcSuccessStruct,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Infer } from 'superstruct';\nimport {\n  array,\n  assign,\n  enums,\n  is,\n  literal,\n  nullable,\n  object,\n  omit,\n  optional,\n  record,\n  string,\n  tuple,\n  union,\n} from 'superstruct';\n\nexport const JsonRpcRequestWithoutIdStruct = assign(\n  omit(JsonRpcRequestStruct, ['id']),\n  object({\n    id: optional(JsonRpcIdStruct),\n  }),\n);\n\nexport type JsonRpcRequestWithoutId = Infer<\n  typeof JsonRpcRequestWithoutIdStruct\n>;\n\nexport const EndowmentStruct = string();\nexport type Endowment = Infer<typeof EndowmentStruct>;\n\n/**\n * Check if the given value is an endowment.\n *\n * @param value - The value to check.\n * @returns Whether the value is an endowment.\n */\nexport function isEndowment(value: unknown): value is Endowment {\n  return is(value, EndowmentStruct);\n}\n\n/**\n * Check if the given value is an array of endowments.\n *\n * @param value - The value to check.\n * @returns Whether the value is an array of endowments.\n */\nexport function isEndowmentsArray(value: unknown): value is Endowment[] {\n  return Array.isArray(value) && value.every(isEndowment);\n}\n\nconst OkStruct = literal('OK');\n\nexport const PingRequestArgumentsStruct = optional(\n  union([literal(undefined), array()]),\n);\n\nexport const TerminateRequestArgumentsStruct = union([\n  literal(undefined),\n  array(),\n]);\n\nexport const ExecuteSnapRequestArgumentsStruct = tuple([\n  string(),\n  string(),\n  optional(array(EndowmentStruct)),\n]);\n\nexport const SnapRpcRequestArgumentsStruct = tuple([\n  string(),\n  enums(Object.values(HandlerType)),\n  string(),\n  assign(\n    JsonRpcRequestWithoutIdStruct,\n    object({\n      params: optional(record(string(), JsonStruct)),\n    }),\n  ),\n]);\n\nexport type PingRequestArguments = Infer<typeof PingRequestArgumentsStruct>;\nexport type TerminateRequestArguments = Infer<\n  typeof TerminateRequestArgumentsStruct\n>;\n\nexport type ExecuteSnapRequestArguments = Infer<\n  typeof ExecuteSnapRequestArgumentsStruct\n>;\n\nexport type SnapRpcRequestArguments = Infer<\n  typeof SnapRpcRequestArgumentsStruct\n>;\n\nexport type RequestArguments =\n  | PingRequestArguments\n  | TerminateRequestArguments\n  | ExecuteSnapRequestArguments\n  | SnapRpcRequestArguments;\n\nexport const OnTransactionRequestArgumentsStruct = object({\n  // TODO: Improve `transaction` type.\n  transaction: record(string(), JsonStruct),\n  chainId: ChainIdStruct,\n  transactionOrigin: nullable(string()),\n});\n\nexport type OnTransactionRequestArguments = Infer<\n  typeof OnTransactionRequestArgumentsStruct\n>;\n\n/**\n * Asserts that the given value is a valid {@link OnTransactionRequestArguments}\n * object.\n *\n * @param value - The value to validate.\n * @throws If the value is not a valid {@link OnTransactionRequestArguments}\n * object.\n */\nexport function assertIsOnTransactionRequestArguments(\n  value: unknown,\n): asserts value is OnTransactionRequestArguments {\n  assertStruct(\n    value,\n    OnTransactionRequestArgumentsStruct,\n    'Invalid request params',\n  );\n}\n\nconst baseNameLookupArgs = { chainId: ChainIdStruct };\nconst domainRequestStruct = object({\n  ...baseNameLookupArgs,\n  address: string(),\n});\nconst addressRequestStruct = object({\n  ...baseNameLookupArgs,\n  domain: string(),\n});\n\nexport const OnNameLookupRequestArgumentsStruct = union([\n  domainRequestStruct,\n  addressRequestStruct,\n]);\n\nexport type OnNameLookupRequestArguments = Infer<\n  typeof OnNameLookupRequestArgumentsStruct\n>;\n\nexport type PossibleLookupRequestArgs = typeof baseNameLookupArgs & {\n  address?: string;\n  domain?: string;\n};\n\n/**\n * Asserts that the given value is a valid {@link OnNameLookupRequestArguments}\n * object.\n *\n * @param value - The value to validate.\n * @throws If the value is not a valid {@link OnNameLookupRequestArguments}\n * object.\n */\nexport function assertIsOnNameLookupRequestArguments(\n  value: unknown,\n): asserts value is OnNameLookupRequestArguments {\n  assertStruct(\n    value,\n    OnNameLookupRequestArgumentsStruct,\n    'Invalid request params',\n  );\n}\n\nconst OkResponseStruct = assign(\n  JsonRpcSuccessStruct,\n  object({\n    result: OkStruct,\n  }),\n);\n\nconst SnapRpcResponse = JsonRpcSuccessStruct;\n\nexport type OkResponse = Infer<typeof OkResponseStruct>;\nexport type SnapRpcResponse = Infer<typeof SnapRpcResponse>;\n\nexport type Response = OkResponse | SnapRpcResponse;\n\ntype RequestParams<Params extends unknown[] | undefined> =\n  Params extends undefined ? [] : Params;\n\ntype RequestFunction<\n  Args extends RequestArguments,\n  ResponseType extends JsonRpcSuccess<Json>,\n> = (...args: RequestParams<Args>) => Promise<ResponseType['result']>;\n\nexport type Ping = RequestFunction<PingRequestArguments, OkResponse>;\nexport type Terminate = RequestFunction<TerminateRequestArguments, OkResponse>;\nexport type ExecuteSnap = RequestFunction<\n  ExecuteSnapRequestArguments,\n  OkResponse\n>;\nexport type SnapRpc = RequestFunction<SnapRpcRequestArguments, SnapRpcResponse>;\n"],"names":["ChainIdStruct","HandlerType","assertStruct","JsonRpcIdStruct","JsonRpcRequestStruct","JsonRpcSuccessStruct","JsonStruct","array","assign","enums","is","literal","nullable","object","omit","optional","record","string","tuple","union","JsonRpcRequestWithoutIdStruct","id","EndowmentStruct","isEndowment","value","isEndowmentsArray","Array","isArray","every","OkStruct","PingRequestArgumentsStruct","undefined","TerminateRequestArgumentsStruct","ExecuteSnapRequestArgumentsStruct","SnapRpcRequestArgumentsStruct","Object","values","params","OnTransactionRequestArgumentsStruct","transaction","chainId","transactionOrigin","assertIsOnTransactionRequestArguments","baseNameLookupArgs","domainRequestStruct","address","addressRequestStruct","domain","OnNameLookupRequestArgumentsStruct","assertIsOnNameLookupRequestArguments","OkResponseStruct","result","SnapRpcResponse"],"mappings":"AAAA,SAASA,aAAa,EAAEC,WAAW,QAAQ,wBAAwB;AAEnE,SACEC,YAAY,EACZC,eAAe,EACfC,oBAAoB,EACpBC,oBAAoB,EACpBC,UAAU,QACL,kBAAkB;AAEzB,SACEC,KAAK,EACLC,MAAM,EACNC,KAAK,EACLC,EAAE,EACFC,OAAO,EACPC,QAAQ,EACRC,MAAM,EACNC,IAAI,EACJC,QAAQ,EACRC,MAAM,EACNC,MAAM,EACNC,KAAK,EACLC,KAAK,QACA,cAAc;AAErB,OAAO,MAAMC,gCAAgCZ,OAC3CM,KAAKV,sBAAsB;IAAC;CAAK,GACjCS,OAAO;IACLQ,IAAIN,SAASZ;AACf,IACA;AAMF,OAAO,MAAMmB,kBAAkBL,SAAS;AAGxC;;;;;CAKC,GACD,OAAO,SAASM,YAAYC,KAAc;IACxC,OAAOd,GAAGc,OAAOF;AACnB;AAEA;;;;;CAKC,GACD,OAAO,SAASG,kBAAkBD,KAAc;IAC9C,OAAOE,MAAMC,OAAO,CAACH,UAAUA,MAAMI,KAAK,CAACL;AAC7C;AAEA,MAAMM,WAAWlB,QAAQ;AAEzB,OAAO,MAAMmB,6BAA6Bf,SACxCI,MAAM;IAACR,QAAQoB;IAAYxB;CAAQ,GACnC;AAEF,OAAO,MAAMyB,kCAAkCb,MAAM;IACnDR,QAAQoB;IACRxB;CACD,EAAE;AAEH,OAAO,MAAM0B,oCAAoCf,MAAM;IACrDD;IACAA;IACAF,SAASR,MAAMe;CAChB,EAAE;AAEH,OAAO,MAAMY,gCAAgChB,MAAM;IACjDD;IACAR,MAAM0B,OAAOC,MAAM,CAACnC;IACpBgB;IACAT,OACEY,+BACAP,OAAO;QACLwB,QAAQtB,SAASC,OAAOC,UAAUX;IACpC;CAEH,EAAE;AAqBH,OAAO,MAAMgC,sCAAsCzB,OAAO;IACxD,oCAAoC;IACpC0B,aAAavB,OAAOC,UAAUX;IAC9BkC,SAASxC;IACTyC,mBAAmB7B,SAASK;AAC9B,GAAG;AAMH;;;;;;;CAOC,GACD,OAAO,SAASyB,sCACdlB,KAAc;IAEdtB,aACEsB,OACAc,qCACA;AAEJ;AAEA,MAAMK,qBAAqB;IAAEH,SAASxC;AAAc;AACpD,MAAM4C,sBAAsB/B,OAAO;IACjC,GAAG8B,kBAAkB;IACrBE,SAAS5B;AACX;AACA,MAAM6B,uBAAuBjC,OAAO;IAClC,GAAG8B,kBAAkB;IACrBI,QAAQ9B;AACV;AAEA,OAAO,MAAM+B,qCAAqC7B,MAAM;IACtDyB;IACAE;CACD,EAAE;AAWH;;;;;;;CAOC,GACD,OAAO,SAASG,qCACdzB,KAAc;IAEdtB,aACEsB,OACAwB,oCACA;AAEJ;AAEA,MAAME,mBAAmB1C,OACvBH,sBACAQ,OAAO;IACLsC,QAAQtB;AACV;AAGF,MAAMuB,kBAAkB/C"}